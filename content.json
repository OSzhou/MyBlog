{"meta":{"title":"Fighting","subtitle":null,"description":null,"author":"Zhouheng","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"iOS系统音量&屏幕亮度调节","slug":"iOS系统音量-屏幕亮度调节","date":"2017-10-12T07:35:14.000Z","updated":"2017-10-13T03:01:44.000Z","comments":true,"path":"2017/10/12/iOS系统音量-屏幕亮度调节/","link":"","permalink":"http://yoursite.com/2017/10/12/iOS系统音量-屏幕亮度调节/","excerpt":"一，系统音量获取系统框架123#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt;#import &lt;AVKit/AVKit.h&gt; 获取系统音量slider1234567891011121314- (MPVolumeView *)volumeView &#123; if (_volumeView == nil) &#123; _volumeView = [[MPVolumeView alloc] init]; [_volumeView sizeToFit];#warning 获取系统的音量的UISlider for (UIView *view in [_volumeView subviews])&#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123; self.volumeViewSlider = (UISlider*)view; break; &#125; &#125; &#125; return _volumeView;&#125;","text":"一，系统音量获取系统框架123#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt;#import &lt;AVKit/AVKit.h&gt; 获取系统音量slider1234567891011121314- (MPVolumeView *)volumeView &#123; if (_volumeView == nil) &#123; _volumeView = [[MPVolumeView alloc] init]; [_volumeView sizeToFit];#warning 获取系统的音量的UISlider for (UIView *view in [_volumeView subviews])&#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123; self.volumeViewSlider = (UISlider*)view; break; &#125; &#125; &#125; return _volumeView;&#125; 监听系统物理按键调节音量12345678910/** 监听 */- (void)registerVolumeChangeEvent &#123;// NSError *error;// [[AVAudioSession sharedInstance] setActive:YES error:&amp;error]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeVolumeValueFunc) name:@&quot;AVSystemController_SystemVolumeDidChangeNotification&quot; object:nil];&#125;/** 移除 */- (void)unregisterVolumeChangeEvent &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;AVSystemController_SystemVolumeDidChangeNotification&quot; object:nil];&#125; 获取系统当前音量1[[AVAudioSession sharedInstance] outputVolume]; 二，屏幕亮度很简单就一句 123456789[[UIScreen mainScreen] setBrightness:值（0 ~ 1）]//示例 if (panPoint.y &lt; 0) &#123; //增加亮度 [[UIScreen mainScreen] setBrightness:self.startVB + (-panPoint.y / 30.0 / 10)]; &#125; else &#123; //减少亮度 [[UIScreen mainScreen] setBrightness:self.startVB - (panPoint.y / 30.0 / 10)]; &#125;","categories":[],"tags":[]},{"title":"UIButton重复点击解决方案","slug":"UIButton重复点击解决方案","date":"2017-10-12T07:33:26.000Z","updated":"2017-10-13T03:18:23.000Z","comments":true,"path":"2017/10/12/UIButton重复点击解决方案/","link":"","permalink":"http://yoursite.com/2017/10/12/UIButton重复点击解决方案/","excerpt":"项目需求，为了防止用户连续点击，造成重复请求，需要设置UIButton点击后，一段时间间隔内不能点击。这个做开发经常用到，在这小小总结下： 方式一（非主流）：继承于NSObject写个工具类1.声明一个静态变量记录上次的点击时间1static long LAST_CLICK_TIME1 = 0;","text":"项目需求，为了防止用户连续点击，造成重复请求，需要设置UIButton点击后，一段时间间隔内不能点击。这个做开发经常用到，在这小小总结下： 方式一（非主流）：继承于NSObject写个工具类1.声明一个静态变量记录上次的点击时间1static long LAST_CLICK_TIME1 = 0; 2.声明一个方法及实现如下（思路很简单就直接上代码了）1234567891011121314/** * 根据传过来的时间间隔进行是否快速点击判断； * opIntervalTime ： 时间间隔，单位毫秒； **/+(bool)isFastDoubleClick1:(long)opIntervalTime&#123; NSDate* date = [NSDate dateWithTimeIntervalSinceNow:0]; long time = [date timeIntervalSince1970] * 1000; long intervalTime = time - LAST_CLICK_TIME1; if(0 &lt; intervalTime &amp;&amp; intervalTime &lt; opIntervalTime)&#123; return true; &#125; LAST_CLICK_TIME1 = time; return false;&#125; 参数说明注释写得很清楚，用法也很简单，就不多说了。 方式二（较主流）给UIButton写个分类（category）1.分类.h文件 12345#import &lt;UIKit/UIKit.h&gt;@interface UIButton (FMExtension)/** 两次点击最大时间间隔，在此时间内，所有点击事件不不执行 */@property (nonatomic, assign) NSTimeInterval fm_multipleClickInterval;@end 由于category 中声明的property，只会生成属性的方法而不会生成方法的实现及“_”变量，所以.m中要用runtime进行属性的动态绑定。2.分类.m 文件具体实现步骤2.1引入runtime头文件 12345678910#import &quot;UIButton+FMExtension.h&quot;#import &lt;objc/runtime.h&gt;@interface UIButton ()/** 记录上一次接收点击事件的时间 */@property(nonatomic, assign) NSTimeInterval fm_acceptEventTime;@end/** 关联关键字 */static const char *UIControl_multipleClickInterval = &quot;fm_multipleClickInterval&quot;;static const char *UIControl_acceptEventTime = &quot;fm_acceptEventTime&quot;;@implementation UIButton (FMExtension) 2.2动态关联对象1234567891011121314/** 动态关联对象 */- (void)setFm_multipleClickInterval:(NSTimeInterval)fm_multipleClickInterval &#123; //四个参数：源对象，关键字，关联的对象和一个关联策略 objc_setAssociatedObject(self, UIControl_multipleClickInterval, @(fm_multipleClickInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSTimeInterval)fm_multipleClickInterval &#123; return [objc_getAssociatedObject(self, UIControl_multipleClickInterval) doubleValue];&#125;- (void)setFm_acceptEventTime:(NSTimeInterval)fm_acceptEventTime &#123; objc_setAssociatedObject(self, UIControl_acceptEventTime, @(fm_acceptEventTime), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSTimeInterval)fm_acceptEventTime &#123; return [objc_getAssociatedObject(self, UIControl_acceptEventTime) doubleValue];&#125; 2.3交换方法123456789101112131415161718192021222324252627282930313233343536373839404142434445//交换方法//以上主要是实现两个方法的互换,load是gcd的只shareinstance，果断保证执行一次+ (void)load &#123; //获取着两个方法 //系统方法 Method sysMethod = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:)); SEL sysM = @selector(sendAction:to:forEvent:); //自定义方法 Method myMethod = class_getInstanceMethod(self, @selector(fm_sendAction:to:forEvent:)); SEL myM = @selector(fm_sendAction:to:forEvent:); //添加方法进去（系统方法名执行自己的自定义函数，相当于重写父类方法） BOOL overrideSuccess = class_addMethod(self, sysM, method_getImplementation(myMethod), method_getTypeEncoding(myMethod)); //如果添加成功 if (overrideSuccess) &#123; //自定义函数名执行系统函数 class_replaceMethod(self, myM, method_getImplementation(sysMethod), method_getTypeEncoding(sysMethod)); &#125; else &#123; method_exchangeImplementations(sysMethod, myMethod); &#125; //这样也可以交换方法（但是注意顺序） /****** * *个人理解： *不管是add还是replace和系统重名的方法，都是相当于复制了一个和系统重名的函数（也就是 *相当于继承重写了父类方法 ps:分类中不支持继承！系统发现有这个方法会优先调用） *系统自动复制一个与自己同名的方法给开发人员用，但是method_getImplementation(systemMethod) *还是获取系统自带方法的属性 * ******/ /* class_replaceMethod(self, sysM, method_getImplementation(myMethod), method_getTypeEncoding(myMethod)); class_replaceMethod(self, myM, method_getImplementation(sysMethod), method_getTypeEncoding(sysMethod)); */&#125;- (void)fm_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123; if (NSDate.date.timeIntervalSince1970 - self.fm_acceptEventTime &lt; self.fm_multipleClickInterval) return; if (self.fm_multipleClickInterval &gt; 0) &#123; self.fm_acceptEventTime = NSDate.date.timeIntervalSince1970;//记录上次点击的时间 &#125; //这里并不是循环调用，由于交换了两个方法，fm_sendAction:to:forEvent:现在就是sendAction:to:forEvent: [self fm_sendAction:action to:target forEvent:event];&#125;@end 代码注释写的比较详细了（自我感觉还阔以吧），就不再多说什么。PS: 交换方法那，有个人的一点小小见解，不知道对不对，欢迎大牛批评指正！！！","categories":[],"tags":[]},{"title":"类似“今日头条”频道编辑功能UI实现","slug":"类似“今日头条”频道编辑功能UI实现","date":"2017-10-12T07:32:08.000Z","updated":"2017-10-13T03:09:28.000Z","comments":true,"path":"2017/10/12/类似“今日头条”频道编辑功能UI实现/","link":"","permalink":"http://yoursite.com/2017/10/12/类似“今日头条”频道编辑功能UI实现/","excerpt":"FMChannelEdit这是一个类似“今日头条”频道编辑功能 前言 站在巨人的肩膀上编程：这个项目的channel编辑页面是在两位前辈代码的基础上，进一步的修改，封装。前辈一：codeWorm2015(GitHubID)源码地址前辈二：HelloYeah(GitHubID)源码地址 PS：这两位具体是谁，我也不认识，想和他们具体交流的，请去GitHub上给他们留言，我这能帮你们到这了。 进入正题 （以下均为个人见解，理解不对还望见谅）","text":"FMChannelEdit这是一个类似“今日头条”频道编辑功能 前言 站在巨人的肩膀上编程：这个项目的channel编辑页面是在两位前辈代码的基础上，进一步的修改，封装。前辈一：codeWorm2015(GitHubID)源码地址前辈二：HelloYeah(GitHubID)源码地址 PS：这两位具体是谁，我也不认识，想和他们具体交流的，请去GitHub上给他们留言，我这能帮你们到这了。 进入正题 （以下均为个人见解，理解不对还望见谅） 之所以用着两位前辈的代码，是因为，虽然实现是同一UI效果，但是思路不同，下面一一讲解方式一：(对应前辈一的实现思路) 思路：完全自定义。自定义channelView（项目中名称：TouchView）继承于UIView,绑定需要的label，imageView，pan,tap,longPress手势，在对应的手势实现中计算出每个channel的index，然后刷新frame（具体实现请参考代码） 优点：自定义程度高，自定义功能的添加修改比较方便，尤其动画比较流畅； 缺点：要同时处理四个数组的数据（两个数据源的，两个视图的），frame刷新频率较高，且都是自己实现的frame刷新，性能可能不如原生的控件（只是可能） 我的完善：原框架功能已经比较完善，只是缺少个下滑移除功能（已添加） GIF效果图： 方式二：(对应前辈二的实现思路) 思路：在UICollectionView的基础上进一步的修改封装。（具体实现请参考代码） 优点：只需要处理两个数据源就可以（上部&amp;下部），视图由UICollectionView自己处理，包括动画效果也是系统自己完成； 缺点：基于UICollectionView，功能的拓展受到一定的限制，动画不如方式一看这舒服。 我的完善：原框架功能较少（相对于今日头条的channel编辑效果），只有上部分的排序和删除。（下部及其他功能已添加） GIF效果图： 其他功能 标题内容对应滑动，滑动后标题居中 标题随滑动，字体大小变化 子视图内，有颜色渐变小Demo GIF效果图： QQ Popover弹框效果GIF效果图： Demo下载","categories":[],"tags":[]},{"title":"UICollectionView下拉刷新闪一下问题解决","slug":"UICollectionView下拉刷新闪一下问题解决","date":"2017-10-12T07:31:08.000Z","updated":"2017-10-12T09:19:32.000Z","comments":true,"path":"2017/10/12/UICollectionView下拉刷新闪一下问题解决/","link":"","permalink":"http://yoursite.com/2017/10/12/UICollectionView下拉刷新闪一下问题解决/","excerpt":"","text":"最近写项目遇到UICollectionView的下拉刷新数据回来时，屏幕会闪一下，在网上找了几个方法，亲自试了都不好使，后来自己试了下回主线程刷新UI，发现可以，代码如下:123dispatch_async(dispatch_get_main_queue(), ^&#123; [self.collectionView reloadData]; &#125;); 大家都知道，在子线程刷新UI是很危险的，有时会出现莫名的Bug, 有些情况甚至会直接崩溃。而网络数据的请求一般都是在子线程进行的，数据回来时去刷新UI（UITableView 和 UIConllectionView）但是UITableView在子线程刷新UI没有出现这个Bug（估计苹果做了优化）。","categories":[],"tags":[]},{"title":"WYYKTScroll控件悬停","slug":"WYYKTScroll控件悬停","date":"2017-10-12T07:25:30.000Z","updated":"2017-10-13T03:24:56.000Z","comments":true,"path":"2017/10/12/WYYKTScroll控件悬停/","link":"","permalink":"http://yoursite.com/2017/10/12/WYYKTScroll控件悬停/","excerpt":"效果示例### 这是一个控件悬停的UI效果实现，类似于网易云课堂的详情页UI效果","text":"效果示例### 这是一个控件悬停的UI效果实现，类似于网易云课堂的详情页UI效果 1.工程引入FMBaseViewController, 并添加要自定义的controller 有关头部image及button的相关设置通过，FMBaseViewController的属性进行设置，示例代码如下：123456789FMBaseViewController *bvc = [[FMBaseViewController alloc] init];bvc.btnBackColor = [UIColor cyanColor];bvc.btnTitleArr = @[@&quot;张三&quot;, @&quot;李四&quot;, @&quot;王五&quot;];bvc.indicatorColor = [UIColor yellowColor];bvc.isIndicatorHidden = YES;bvc.headImage_H = 100;bvc.button_H = 30;bvc.headImageName = @&quot;picture_3&quot;;bvc.isStretch = NO; 2.注意：自定义的controller 必须继承于FMParentViewController.h, 并且子控制器暂时只支持UITableViewController 子控制器类型1 ：FMTableViewStylePlain 初始化代码如下： 123FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStylePlain];或者（default）FMT1ViewController *t1 = [[FMT1ViewController alloc] init]; 子控制器类型2：FMTableViewStyleGroup 初始化代码如下： 1234FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStyleGrouped];或者（用属性修改）FMT1ViewController *t2 = [[FMT1ViewController alloc] init];t2.tableViewStyle = FMTableViewStyleGrouped; 3.头部视图是否可以拉伸： 1isStretch 属性（default is YES） 测试效果查看，在AppDelegate.m 的launch函数中添加（或替换）如下代码： 123FMBaseViewController *bvc = [[FMBaseViewController alloc] init]; self.window.rootViewController = bvc; [self.window makeKeyAndVisible]; 自定义子controller初始化后传入该数组childVCArr，示例代码如下： 12345FMBaseViewController *bvc = [[FMBaseViewController alloc] init];FMT1ViewController *t1 = [[FMT1ViewController alloc] init];FMT2ViewController *t2 = [[FMT2ViewController alloc] initWithTableViewStyle:FMTableViewStyleGrouped];FMT3ViewController *t3= [[FMT3ViewController alloc] init];bvc.childVCArr = @[t1, t2, t3]; ####子控制器最好不要超过5个， 暂不支持滑动（以后可能添加，敬请期待！） headView上的内容可自定义添加，通过 ftc.headView可拿到head部分的视图添加自己的控件。 支持cocoaPods 安装 1234pod search WYTest在Podfile中添加pod &quot;WYTest&quot;pod install || pod update ##github Demo下载地址点击去下载","categories":[],"tags":[]},{"title":"如何利用pod trunk发布程序","slug":"如何使项目支持cocoaPods","date":"2017-10-11T06:16:01.000Z","updated":"2017-10-13T03:26:06.000Z","comments":true,"path":"2017/10/11/如何使项目支持cocoaPods/","link":"","permalink":"http://yoursite.com/2017/10/11/如何使项目支持cocoaPods/","excerpt":"refer to CoderMJLee注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息","text":"refer to CoderMJLee注册 pod trunk register 邮箱 &#39;用户名&#39; --description=&#39;电脑描述&#39; 查收邮件 如果是QQ邮箱，可能会被放到“垃圾箱”中，并不一定是“收件箱” 点击邮件中的链接：https://trunk.cocoapods.org/sessions/verify/xxxx 接下来查看个人信息 pod trunk me 123456- Name: MJ Lee- Email: xxxxxx@qq.com- Since: January 28th, 03:53- Pods: None- Sessions: - January 28th, 04:28 - June 5th, 04:34. IP: xxx.xxx.xxx.xxx Description: Macbook Pro 中间可能遇到这种错误 1NoMethodError - undefined method &apos;last&apos; for #&lt;Netrc::Entry:0x007fc59c246378&gt; 这时候需要尝试更新gem源或者pod sudo gem update --system sudo gem install cocoapods sudo gem install cocospods-trunk 创建podspec文件 接下来需要在项目根路径创建一个podspec文件来描述你的项目信息 pod spec create 文件名 比如pod spec cretae MJExtension就会生成一个MJExtension.podspec 填写podspec内容1234567891011121314Pod::Spec.new do |s| s.name = &quot;MJExtension&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;The fastest and most convenient conversion between JSON and model&quot; s.homepage = &quot;https://github.com/CoderMJLee/MJExtension&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;MJLee&quot; =&gt; &quot;xxxxx@qq.com&quot; &#125; s.social_media_url = &quot;http://weibo.com/exceptions&quot; s.source = &#123; :git =&gt; &quot;https://github.com/CoderMJLee/MJExtension.git&quot;, :tag =&gt; s.version &#125; s.frameworks = &quot;UIKit&quot;, &quot;Foundation&quot; s.platform = :ios, &quot;8.0&quot; s.source_files = &quot;MJExtensionExample/MJExtensionExample/MJExtension&quot; s.requires_arc = trueend 值得注意的是，现在的podspec必须有tag，所以最好先打个tag，传到github git tag 0.0.1 git push --tags 检测podspec语法 pod spec lint MJExtension.podspec 发布podspec pod trunk push MJExtension.podspec 如果是第一次发布pod，需要去https://trunk.cocoapods.org/claims/new认领pod 检测 pod setup : 初始化 pod repo update : 更新仓库 pod search MJExtension 仓库更新 如果仓库更新慢，可以考虑更换仓库镜像 pod repo remove master pod repo add master http://git.oschina.net/akuandev/Specs.gitpodspec 更新版本步骤 1.代码修改 2.修改podspec文件中的version 版本号 3.git tag (后跟版本号)&amp; git push —-tags同步远程仓库版本号 4.将本地的代码提交远程仓库（更新版本号） 5.pod trunk push xxx.podspec 提交最新的podspec文件 注意：提交的代码里最好不要有警告","categories":[],"tags":[]}]}